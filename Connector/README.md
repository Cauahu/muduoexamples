###1. SIGPIPE信号
- 如果在写入套接字时，对端已经关闭，那么此时就会收到一个 SIGPIPE 信号，该信号默认情况下会终止当前进程。这就可能造成程序的异常终止。
- 解决办法是，设置信号处理函数，或者程序启动时忽略该信号。
- 示例程序下：服务器在休眠期间，客户端关闭连接，当服务器休眠后向客户端发送数据，因为此时连接已经断开，因为服务器就会受到SIGPIPE信号，造成服务器程序终止。
在EventLoop时间循环初始化的时候就忽略该信号，或者在main函数中忽略该信号，然后同样的情况发生时，服务器就会不会异常终止，而是按照之前正常结束的逻辑结束，即套接字可读，read返回0，处理关闭事件。

###2. TCP No Delay 和 Keepalive
TCP连接默认是开启Nagle算法的，该算法是为了解决过多的小包在网络上发送造成的网络拥塞，对于一个TCP连接，任意时刻只允许存在一个未被确认的报文，也就是说，如果没有收到上一个报文的确认，那么下一个报文就不能发送出去。

但是针对一些对时延要求很高的应用，开启该算法可能会组织包的连续发送，从而造成一定的时延，因此muduo使用setsockopt系统调用来设置TCP_NODELAY选项，关闭该算法。

Keepalive是保活选项，对于一个TCP连接来说，默认是不开启该选项的，但是这对于服务器端就可能造成一个问题，即可能存在半开放的连接，连接一直存在但是没有数据传输，此时可能对端已经关闭或者重启等，服务器就需要获得该客户机的状态，以此来决定是否保持该连接，毕竟服务器的资源是有限的。

同样，muduo使用setsockopt系统调用的SO_KEEPALIVE参数来设置该选项。

###3. 低水位回调（写完回调）
低水位回调是针对这样一种情况，如果发送数据的速度大于对方接收的速度，那么受到对方通告窗口的限制，要发送的数据就会在本地内核发送缓冲区中堆积，进而堆积到上层应用层的发送缓冲区中，最终可能造造成应用层发送缓冲区溢出。

因而，解决办法就是，当应用层发送缓存区为空时，调用低水位回调函数，即这里的writeCompleteCallback_函数，再发送数据，这样可以保证应用层缓冲区不会堆积过多的数据，导致溢出，还可以减慢发送端发送数据的速度，使得对端来得及接收。

###4. 高水位回调
这里的高低水位都是针对缓冲区的现状的，低水位即缓冲区为空，高水位即缓冲区满。
高水位回调是针对应用层发送缓冲区满的情况，此时不能继续发送数据了，因此添加了一个高水位回调函数，用于停止发送数据。


